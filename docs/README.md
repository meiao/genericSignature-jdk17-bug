# Investigation

It was first pointed out that a call to get a method generic return type was throwing an exception.

During the [investigation](https://github.com/newrelic/newrelic-java-agent/issues/526) it was found that the exception was thrown while gathering the method's data.

And the cause of the exception was that the signature returned by `Class#getGenericSignature0` was `java/util/concurrent/CompletableFuture` while the correct value is `<T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/concurrent/Future<TT;>;`.

Given that `Class#getGenericSignature0` is a native method, the next step was to inspect the generated bytecode.

A simplified version of the instrumentation was created. This version did not change anything in the code, it only adds a couple of annotations to the class. Even then the problem persisted. And looking at the bytecode, both instrumented and original contain a line with the proper signature: 
`Signature: #xyz // <T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/concurrent/Future<TT;>;Ljava/util/concurrent/CompletionStage<TT;>;`.

Bytecodes:
- [original CompletableFuture](CompletableFuture.bytecode.txt).
- [instrumented CompletableFuture](CompletableFuture-instrumented.bytecode.txt)

Further comparing the bytecodes, the only differences are the order of the items in the constant pool (which cause the references throught the class to change), the order of the methods and the order of the tables in each method (LineNumberTable, LocalVariableTable, LocalVariableTypeTable).

Since the bytecode did not provide any clue, the next step was to debug the JVM itself.

`ClassFileParser::apply_parsed_class_attributes` is called twice for `CompletableFuture`. Once before instrumentation and once after. And in both cases, the `_generic_signature_index` is correct.

Following the execution to `VM_RedefineClasses::merge_cp_and_rewrite`:
```c++
1794  jvmtiError VM_RedefineClasses::merge_cp_and_rewrite(
1795               InstanceKlass* the_class, InstanceKlass* scratch_class,
1796               TRAPS) {
...
...       // point A
1916      if (!rewrite_cp_refs(scratch_class)) { 
1917        return JVMTI_ERROR_INTERNAL;
1918      }
...       // point B
...
1924      set_new_constant_pool(loader_data, scratch_class, merge_cp, merge_cp_length,
1925                            CHECK_(JVMTI_ERROR_OUT_OF_MEMORY));
...       // point C
...
1931      cp_cleaner.add_scratch_cp(scratch_cp());
...
```
At point A, `scratch_class->generic_signature()` is correct and `generic_signature_index` is 4.

At point B, `scratch_class->generic_signature()` is wrong, its value changes with each run, and `generic_signature_index` is 1019.

At point C, `scratch_class->generic_signature()` is the value observed at runtime and `generic_signature_index` is 4. Also `scratch_class->constants()->symbol_at(1019)` has the correct generic signature.

Note that 1019 is the index for the generic signature in the original bytecode and 4 is the index for the generic signature in the instrumented bytecode.

Inside `VM_RedefineClasses::rewrite_cp_refs` the explanation to what happens between points A and B.
```
1936  bool VM_RedefineClasses::rewrite_cp_refs(InstanceKlass* scratch_class) {
...
2024    // rewrite class generic signature index:
2025    u2 generic_signature_index = scratch_class->generic_signature_index(); // this is set to 4
2026    if (generic_signature_index != 0) {
2027      u2 new_generic_signature_index = find_new_index(generic_signature_index); // this is set to 1019
2028      if (new_generic_signature_index != 0) {
2029        scratch_class->set_generic_signature_index(new_generic_signature_index);
2030      }
2031    }
...
```
