# Investigation

It was first pointed out that a call to get a method generic return type was throwing an exception.

During the [investigation](https://github.com/newrelic/newrelic-java-agent/issues/526) it was found that the exception was thrown while gathering the method's data.

And the cause of the exception was that the signature returned by `Class#getGenericSignature0` was `java/util/concurrent/CompletableFuture` while the correct value is `<T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/concurrent/Future<TT;>;`.

Given that `Class#getGenericSignature0` is a native method, the next step was to inspect the generated bytecode.

A simplified version of the instrumentation was created. This version did not change anything in the code, it only adds a couple of annotations to the class. Even then the problem persisted. And looking at the bytecode, both instrumented and original contain a line with the proper signature: 
`Signature: #xyz // <T:Ljava/lang/Object;>Ljava/lang/Object;Ljava/util/concurrent/Future<TT;>;Ljava/util/concurrent/CompletionStage<TT;>;`.

Bytecodes:
- [original CompletableFuture](CompletableFuture.bytecode.txt).
- [instrumented CompletableFuture](CompletableFuture-instrumented.bytecode.txt)

Further comparing the bytecodes, the only differences are the order of the items in the constant pool (which cause the references throught the class to change), the order of the methods and the order of the tables in each method (LineNumberTable, LocalVariableTable, LocalVariableTypeTable).

Since the bytecode did not provide any clue, the next step was to debug the JVM itself.

`ClassFileParser::apply_parsed_class_attributes` is called twice for `CompletableFuture`. Once before instrumentation and once after. And in both cases, the `_generic_signature_index` is correct.

Following the execution to `VM_RedefineClasses::merge_cp_and_rewrite` a call is made to `VM_RedefineClasses::rewrite_cp_refs`, where the generic signature index is set. At this point, `scratch_class->generic_signature()->as_C_string()` has the correct value (4). When it is about to call `scratch_class->set_generic_signature_index(new_generic_signature_index);`:
- `generic_signature_index` has the index to the correct signature in the instrumented bytecode (4);
- `new_generic_signature_index` has the index to the correct signature in the original bytecode (1019).

And it sets the old index on the new class and the generic signature becomes invalid until the call to `VM_RedefineClasses::set_new_constant_pool`. After this call, the generic_signature_index in the scratch_class' constants is once again set to the index in the instrumented bytecode (4). But at this point, the constant pool in memory has the correct generic signature at the index for the original bytecode (1019).


